"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4620],{388:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"chain_off_responsability","title":"chain_off_responsability","description":"El patr\xf3n Chain of Responsibility es una soluci\xf3n de dise\xf1o que aborda la distribuci\xf3n din\xe1mica de responsabilidades en sistemas complejos. Este enfoque permite procesar solicitudes mediante una cadena de manejadores, donde cada uno eval\xfaa si puede resolver el problema o pasarlo al siguiente elemento en la secuencia. Este modelo fomenta el desacoplamiento entre los emisores y receptores de solicitudes, mejorando la flexibilidad y modularidad del c\xf3digo. En esta introducci\xf3n exploraremos c\xf3mo funciona este patr\xf3n, su utilidad en la programaci\xf3n y ejemplos pr\xe1cticos para entender su implementaci\xf3n y ventajas.","source":"@site/docs/chain_off_responsability.md","sourceDirName":".","slug":"/chain_off_responsability","permalink":"/Documentacion_Doc/docs/chain_off_responsability","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chain_off_responsability.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Visitor","permalink":"/Documentacion_Doc/docs/Visitor"},"next":{"title":"command","permalink":"/Documentacion_Doc/docs/command"}}');var s=n(4848),o=n(8453);const r={},d="chain_off_responsability",l={},t=[{value:"\xbfC\xf3mo Funciona?",id:"c\xf3mo-funciona",level:3},{value:"\xbfC\xf3mo identificar cu\xe1ndo utilizar este patr\xf3n?",id:"c\xf3mo-identificar-cu\xe1ndo-utilizar-este-patr\xf3n",level:3},{value:"\xbfC\xf3mo implementar el patr\xf3n?",id:"c\xf3mo-implementar-el-patr\xf3n",level:3},{value:"Ventajas del uso del patr\xf3n",id:"ventajas-del-uso-del-patr\xf3n",level:3},{value:"Desventajas:",id:"desventajas",level:3},{value:"Diagrama de clases",id:"diagrama-de-clases",level:3},{value:"Estructura",id:"estructura",level:3},{value:"Ejemplo Pr\xe1ctico de C\xf3digo.",id:"ejemplo-pr\xe1ctico-de-c\xf3digo",level:3},{value:"Comparaci\xf3n del patr\xf3n Chain of Responsibility con otros patrones:",id:"comparaci\xf3n-del-patr\xf3n-chain-of-responsibility-con-otros-patrones",level:3},{value:"Casos de uso comunes del patr\xf3n Chain of Responsibility:**",id:"casos-de-uso-comunes-del-patr\xf3n-chain-of-responsibility",level:3}];function c(e){const a={code:"code",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"chain_off_responsability",children:"chain_off_responsability"})}),"\n",(0,s.jsxs)(a.p,{children:["El patr\xf3n ",(0,s.jsx)(a.strong,{children:"Chain of Responsibility"})," es una soluci\xf3n de dise\xf1o que aborda la distribuci\xf3n din\xe1mica de responsabilidades en sistemas complejos. Este enfoque permite procesar solicitudes mediante una cadena de manejadores, donde cada uno eval\xfaa si puede resolver el problema o pasarlo al siguiente elemento en la secuencia. Este modelo fomenta el desacoplamiento entre los emisores y receptores de solicitudes, mejorando la flexibilidad y modularidad del c\xf3digo. En esta introducci\xf3n exploraremos c\xf3mo funciona este patr\xf3n, su utilidad en la programaci\xf3n y ejemplos pr\xe1cticos para entender su implementaci\xf3n y ventajas."]}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.img,{src:"https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility-comic-1-es.png?id=a57afa94531c4b0395559c4d2d675967",alt:""})}),"\n",(0,s.jsx)(a.h3,{id:"c\xf3mo-funciona",children:"\xbfC\xf3mo Funciona?"}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"Cuando se recibe una solicitud, cada manejador:"})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Eval\xfaa si tiene la capacidad para procesarla."}),"\n",(0,s.jsx)(a.li,{children:"Si no puede procesarla, la pasa al siguiente manejador en la cadena."}),"\n",(0,s.jsx)(a.li,{children:"El proceso contin\xfaa hasta que un manejador la resuelve o se agotan los manejadores disponibles."}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Este dise\xf1o es especialmente \xfatil en escenarios donde:"}),"\r\nLas responsabilidades est\xe1n distribuidas jer\xe1rquicamente.\r\nEl manejo de solicitudes debe adaptarse din\xe1micamente.\r\nSe busca desacoplar emisores y receptores para mejorar la modularidad."]}),"\n",(0,s.jsx)(a.h3,{id:"c\xf3mo-identificar-cu\xe1ndo-utilizar-este-patr\xf3n",children:"\xbfC\xf3mo identificar cu\xe1ndo utilizar este patr\xf3n?"}),"\n",(0,s.jsx)(a.p,{children:"La necesidad de aplicar este patr\xf3n se puede identificar en procesos que se basan en pasos secuenciales, donde se deben agregar verificaciones o condiciones. A medida que la funcionalidad crece, el c\xf3digo tiende a saturarse de declaraciones if, lo que puede dificultar su mantenimiento y comprensi\xf3n. El patr\xf3n Chain of Responsibility ayuda a resolver este problema al separar las responsabilidades de cada paso del proceso en clases independientes."}),"\n",(0,s.jsx)(a.p,{children:"Por ejemplo, en el caso del scoring de un pedido, se pueden identificar varios pasos que se deben validar:"}),"\n",(0,s.jsx)(a.p,{children:"\xbfEl cliente del pedido tiene pedidos previos?\r\n\xbfEl cliente realiza el pago con su m\xe9todo de pago habitual?\r\n\xbfEl pedido supera una cierta cantidad?"}),"\n",(0,s.jsx)(a.p,{children:"La aplicaci\xf3n del patr\xf3n permite que cada paso del proceso se separe en distintas clases, donde cada clase tiene una \xfanica responsabilidad. De esta manera, el pedido o solicitud puede ser procesado a trav\xe9s de una cadena de manejadores, que se encargan de evaluar y aplicar cada paso hasta obtener un resultado final. Esto no solo mejora la organizaci\xf3n del c\xf3digo, sino que tambi\xe9n facilita su expansi\xf3n y mantenimiento a medida que se agregan nuevas verificaciones o condiciones."}),"\n",(0,s.jsx)(a.h3,{id:"c\xf3mo-implementar-el-patr\xf3n",children:"\xbfC\xf3mo implementar el patr\xf3n?"}),"\n",(0,s.jsx)(a.p,{children:"Al igual que muchos otros patrones de dise\xf1o de comportamiento, la implementaci\xf3n del patr\xf3n Chain of Responsibility se basa en transformar comportamientos espec\xedficos en objetos independientes denominados Handlers. Cada verificaci\xf3n dentro del proceso debe extraerse a su propia clase, la cual contar\xe1 con un \xfanico m\xe9todo encargado de realizar la acci\xf3n correspondiente. La solicitud, junto con sus datos y contexto, se pasa como argumento a este m\xe9todo, lo que permite iniciar la cadena de responsabilidad."}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.img,{src:"https://miro.medium.com/v2/resize:fit:828/format:webp/0*7PGB4poMp_-feEy2.png",alt:""})}),"\n",(0,s.jsx)(a.p,{children:"Existen m\xfaltiples ejemplos de implementaciones de este patr\xf3n, y se puede adaptar a una amplia variedad de contextos. Al final del art\xedculo, se incluir\xe1 un ejemplo concreto de implementaci\xf3n del patr\xf3n en ES6, para ilustrar c\xf3mo aplicar este enfoque de manera pr\xe1ctica."}),"\n",(0,s.jsx)(a.h3,{id:"ventajas-del-uso-del-patr\xf3n",children:"Ventajas del uso del patr\xf3n"}),"\n",(0,s.jsx)(a.p,{children:"Una vez implementado el patr\xf3n, surgen varias ventajas que demuestran su utilidad. Es importante preguntarse si la jerarqu\xeda de clases creada para aplicarlo realmente aporta beneficios. A continuaci\xf3n, se detallan las principales ventajas del patr\xf3n Chain of Responsibility y los principios SOLID que se cumplen al utilizarlo:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Control del orden de los pasos: El patr\xf3n permite gestionar el orden de ejecuci\xf3n de los pasos de manera din\xe1mica, lo que facilita la modificaci\xf3n del flujo de trabajo sin afectar otras partes del sistema."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Cumplimiento del principio de responsabilidad \xfanica (Single Responsibility Principle): El patr\xf3n desacopla la invocaci\xf3n de las operaciones y la ejecuci\xf3n de las acciones en clases separadas. Esto facilita la prueba de cada acci\xf3n de manera aislada, mejorando la mantenibilidad y claridad del c\xf3digo."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Cumplimiento del principio abierto/cerrado (Open/Closed Principle): La implementaci\xf3n del patr\xf3n facilita la adici\xf3n de nuevos manejadores sin necesidad de modificar el c\xf3digo existente. Esto mejora la escalabilidad y mantenibilidad del sistema, permitiendo que evolucione sin introducir errores en el c\xf3digo que ya est\xe1 funcionando."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"desventajas",children:"Desventajas:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Puede ser dif\xedcil depurar y entender el flujo, especialmente si la cadena es larga y compleja."}),"\n",(0,s.jsx)(a.li,{children:'La petici\xf3n puede quedar sin gestionar si la cadena no incluye un gestor "catch-all".'}),"\n",(0,s.jsx)(a.li,{children:"Pueden surgir problemas de rendimiento debido a la posibilidad de pasar por varios"}),"\n",(0,s.jsx)(a.li,{children:"gestores antes de encontrar el correcto, o no encontrarlo en absoluto."}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"diagrama-de-clases",children:"Diagrama de clases"}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.img,{src:"https://java-design-patterns.com/assets/img/chain-of-responsibility.urm.1c5875a9.png",alt:""})}),"\n",(0,s.jsx)(a.h3,{id:"estructura",children:"Estructura"}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.img,{src:"https://upload.wikimedia.org/wikipedia/commons/1/1f/Chain_of_responsibility.jpg",alt:""})}),"\n",(0,s.jsx)(a.h3,{id:"ejemplo-pr\xe1ctico-de-c\xf3digo",children:"Ejemplo Pr\xe1ctico de C\xf3digo."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-//",metastring:"Clase abstracta base",children:'abstract class Manejador {\r\n    protected Manejador siguienteManejador;\r\n\r\n    public void setSiguiente(Manejador manejador) {\r\n        this.siguienteManejador = manejador;\r\n    }\r\n\r\n    public abstract void manejar(String solicitud);\r\n}\r\n\r\n// Manejadores concretos\r\nclass ManejadorA extends Manejador {\r\n    public void manejar(String solicitud) {\r\n        if ("A".equals(solicitud)) {\r\n            System.out.println("ManejadorA proces\xf3 la solicitud.");\r\n        } else if (siguienteManejador != null) {\r\n            siguienteManejador.manejar(solicitud);\r\n        }\r\n    }\r\n}\r\n\r\nclass ManejadorB extends Manejador {\r\n    public void manejar(String solicitud) {\r\n        if ("B".equals(solicitud)) {\r\n            System.out.println("ManejadorB proces\xf3 la solicitud.");\r\n        } else if (siguienteManejador != null) {\r\n            siguienteManejador.manejar(solicitud);\r\n        }\r\n    }\r\n}\r\n\r\nclass Cliente {\r\n    public static void main(String[] args) {\r\n        Manejador manejadorA = new ManejadorA();\r\n        Manejador manejadorB = new ManejadorB();\r\n\r\n        manejadorA.setSiguiente(manejadorB);\r\n\r\n        manejadorA.manejar("A");\r\n        manejadorA.manejar("B");\r\n        manejadorA.manejar("C");\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(a.h3,{id:"comparaci\xf3n-del-patr\xf3n-chain-of-responsibility-con-otros-patrones",children:"Comparaci\xf3n del patr\xf3n Chain of Responsibility con otros patrones:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Chain of Responsibility vs. Command"}),": Ambos patrones permiten el env\xedo de solicitudes a un objeto que las maneja. Sin embargo, en el patr\xf3n Command, las solicitudes son encapsuladas como objetos y se env\xedan a un invocador para su ejecuci\xf3n. En cambio, en Chain of Responsibility, las solicitudes se pasan a trav\xe9s de una cadena de objetos hasta que uno de ellos las maneja, sin necesidad de encapsular la solicitud."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Chain of Responsibility vs. Observer"}),": Mientras que Chain of Responsibility se enfoca en la forma de delegar la responsabilidad de manejar una solicitud a un conjunto de objetos, Observer se usa para notificar a un conjunto de objetos sobre cambios en el estado de un objeto. Aunque ambos patrones usan la delegaci\xf3n, el Observer se centra m\xe1s en la notificaci\xf3n de eventos, mientras que Chain of Responsibility maneja la solicitud de manera jer\xe1rquica."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Chain of Responsibility vs. Strategy"}),": En Strategy, un objeto delega su comportamiento a un objeto de estrategia, el cual puede ser cambiado en tiempo de ejecuci\xf3n. En Chain of Responsibility, los objetos est\xe1n encadenados y la solicitud se maneja por el primer objeto que pueda procesarla, sin necesidad de cambiar el comportamiento de los objetos en tiempo de ejecuci\xf3n."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"casos-de-uso-comunes-del-patr\xf3n-chain-of-responsibility",children:"Casos de uso comunes del patr\xf3n Chain of Responsibility:**"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Manejo de solicitudes HTTP"}),": En un servidor web, las solicitudes HTTP pueden ser procesadas por diferentes filtros de manera secuencial. Por ejemplo, un filtro podr\xeda verificar la autenticidad de un usuario, otro podr\xeda revisar permisos, y otro podr\xeda hacer la transformaci\xf3n de datos. Si un filtro no puede manejar la solicitud, la pasa al siguiente en la cadena."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Manejo de excepciones"}),": En un sistema de manejo de errores, diferentes objetos o clases pueden encargarse de manejar excepciones espec\xedficas. Si una excepci\xf3n no puede ser manejada por un objeto, se pasa a otro hasta que se encuentra un manejador adecuado o se decide que la excepci\xf3n no puede ser gestionada."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Interfaz de usuario con m\xfaltiples eventos"}),": En una interfaz gr\xe1fica, diferentes manejadores pueden procesar distintos tipos de eventos de entrada, como clics de rat\xf3n o presiones de teclas. Si un evento no es gestionado por un manejador, se pasa al siguiente hasta que uno lo maneje."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Procesamiento de cadenas de texto"}),": Cuando se tiene una serie de transformaciones que deben aplicarse a un texto (como validaci\xf3n, limpieza, formateo, etc.), el patr\xf3n Chain of Responsibility permite que cada transformaci\xf3n sea manejada por un objeto de la cadena, pasando el texto a lo largo de los manejadores hasta que se haya procesado completamente."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>r,x:()=>d});var i=n(6540);const s={},o=i.createContext(s);function r(e){const a=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function d(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:a},e.children)}}}]);